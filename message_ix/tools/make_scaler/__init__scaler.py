import os

import ixmp
import numpy as np
import pandas as pd

from message_ix.tools.lp_diag import LPdiag

lp = LPdiag()
mp = ixmp.Platform()


def filter_df(data, bounds):
    """Extracts matrix elements with coefficient outliers.

    This function extracts elements from a matrix where
    the coefficients deviate from a specified threshold.

    Parameters:
    -----------
    data : pandas DataFrame
        The coefficient matrix, typically generated by
        the mps_sum function in LPDiag.
    bounds: int or list of 2 integers
        Exponent threshold used to identify outlier coefficients.
        If a single integer is provided, the bounds are set to +/- that value.
        If a list of 2 integers is provided, they represent the lower and
        upper bounds of the threshold.

    Examples:
    ---------
    # Extract elements with coefficient exponents deviating beyond +/-3
    extracted_data = filter_df(data_matrix, 3)

    # Extract elements with coefficients exponents deviating
    # beyond the range of -2 to 2
    extracted_data = extract_outliers(data_matrix, [-2, 2])
    """

    if isinstance(bounds, int):
        lo_bound = -bounds
        up_bound = bounds
    else:
        lo_bound = bounds[0]
        up_bound = bounds[1]

    df_filtered = data.loc[(data["val"] <= lo_bound) | (data["val"] >= up_bound)]

    return df_filtered


def make_logdf(data):
    """
    Make log10 of the absolute non zero value element of dataframe.

    """
    log_absdf = data.copy()

    log_absdf.loc[log_absdf["val"] != 0, "val"] = np.log10(
        np.absolute(log_absdf.loc[log_absdf["val"] != 0, "val"])
    )

    return log_absdf


def get_lvl_ix(data, lvl):
    """
    To get level index from coefficient matrix.

    Parameters:
    -----------
    data : pandas DataFrame
        The coefficient matrix, typically generated by
        the mps_sum function in LPDiag.
    lvl : int or str
        0 or "row" for rows and 1 or "col" for columns

    """
    return data.index.get_level_values(lvl)


def show_range(data, pretext):
    """
    To displace coefficient exponents range.

    """

    log_absdf = make_logdf(data)

    print(
        f"{pretext}:",
        "[",
        np.int32(np.min(log_absdf)),  # lower bound
        "|",
        np.int32(np.max(log_absdf)),  # upper bound
        "]",
    )


def get_scaler_args(scenario_ref=None, model="", scenario=""):
    """
    Function to make gams argument for scaling

    """
    if not scenario_ref:
        strings = ["MsgScaler", model, scenario]
    else:
        strings = ["MsgScaler", scenario_ref.model, scenario_ref.scenario]

    file_name = "_".join(s.replace(" ", "_") for s in strings)

    current_directory = os.getcwd()
    two_levels_up = os.path.abspath(os.path.join(current_directory, "../.."))

    prescale_args_dir = os.path.join(two_levels_up, f"model/scaler/{file_name}.gms")

    if os.path.exists(prescale_args_dir):
        return f"--scaler={file_name}"
    else:
        print("The referred scenario doesn't have prescaler file!")
        print("Please use make_prescaler() function to create one")


def make_scaler(path, scen, bounds=4, steps=1, display_range=True):
    """
    Process to generate prescale_args in GAMS to improve
    matrix coefficients.

    This function shifts matrix coefficient exponents to improve
    the scaling properties of the matrix. The function returns
    prescale arguments (prescale_args) to be passed to the GAMS model.

    Parameters:
    -----------
    path: str
        Pathways to locate the mps file.
    bounds: int or list of 2 integers
        Exponent threshold used to identify outlier coefficients.
        If a single integer is provided, the bounds are set to +/- that value.
        If a list of 2 integers is provided, they represent
        the lower and upper bounds of the threshold.
    steps: int
        Number of times the prescaler generation process is repeated.
        Larger values may lead to more refined prescale_args but
        also increase computation time.
    show_range: boolean
        Option to show the coefficient exponents range before and after scaling.
        If True, the function will display the range; otherwise, it will not.

    Returns:
    --------
    prescale_args: dict
        A dictionary of prescale arguments to be passed to the GAMS model.
    """
    lp.read_mps(path)

    data = lp.read_matrix()

    matrix = data

    if display_range is True:
        show_range(matrix, "\nUnscaled range     ")

    scalers = {"row": [], "col": []}

    counter = 0
    while counter < steps:
        for s in scalers.keys():
            # print(matrix)
            # calculate log base 10 of the absolute value of the matrix
            log_absmatrix = make_logdf(matrix)

            # Create matrix with small and large coefficients
            log_absmatrix_solv = filter_df(log_absmatrix, bounds=bounds)

            # Populating row scaler
            objective_ix = "_obj" if s == "row" else "constobj"
            index_solv = [
                e for e in get_lvl_ix(log_absmatrix_solv, s) if e != objective_ix
            ]

            SFs = {k: [] for k in index_solv}
            for k in SFs.keys():
                index_val = get_lvl_ix(log_absmatrix, s) == k
                dflog_val = log_absmatrix.loc[index_val, "val"]
                lb, ub = np.int32(min(dflog_val)), np.int32(max(dflog_val))
                mid = np.int32(np.mean([lb, ub]))

                exp = mid if s == "row" else -mid

                SFs[k] = 10.0 ** (exp)

            # Create DataFrame of row scaler
            return_index = list(set(get_lvl_ix(log_absmatrix, s)))
            if counter == 0:
                multiplier = 1
            else:
                multiplier = scalers[s].reindex(return_index).fillna(1)
            step_scaler = pd.DataFrame(data=SFs, index=["val"]).transpose()
            step_scaler.index.name = s
            step_scaler = step_scaler.reindex(return_index).fillna(1)

            # summarize multipliers from previous steps
            scalers[s] = step_scaler.mul(multiplier)

            # Create new matrix with scaled rows
            matrix = matrix.div(step_scaler) if s == "row" else matrix.mul(step_scaler)

        if display_range is True:
            show_range(matrix, f"Scaled range step {counter + 1}")

        # Increment the counter
        counter += 1

    # generating prescaler arguments for GAMS
    scaler_dict = {}
    for key, df_scaler in scalers.items():
        df_scaler = df_scaler.loc[df_scaler["val"] != 1]
        df_scaler_dict = df_scaler["val"].to_dict()
        for k, v in df_scaler_dict.items():
            if k == "_obj":
                k_ = "_obj.scale"
            elif k == "constobj":
                k_ = "constobj.scale"
            else:
                k_ = k.replace("(", ".scale('")
                k_ = k_.replace(")", "')")
                k_ = k_.replace(",", "','")
            scaler_dict.update({k_: v})

    # add this line to active scaling option
    scaler_dict["MESSAGE_LP.scaleopt"] = 1

    scaler_df = pd.DataFrame(scaler_dict, index=["val"]).transpose()
    scaler_df.index = scaler_df.index.rename("key", inplace=False)

    scaler_list = []
    for k, v in scaler_dict.items():
        scaler_list.append(f"{k}={v};")
    scaler_args_txt = "\n".join(scaler_list)

    current_directory = os.getcwd()
    two_levels_up = os.path.abspath(os.path.join(current_directory, "../.."))

    scaler_gms_name = [scen.model, scen.scenario]
    scaler_gms_name = "_".join(s.replace(" ", "_") for s in scaler_gms_name)

    scaler_gms_dir = os.path.join(
        two_levels_up, f"model/scaler/MsgScaler_{scaler_gms_name}.gms"
    )

    with open(scaler_gms_dir, "w") as txtfile:
        # Write some text to the file
        txtfile.write(scaler_args_txt)

    return scaler_df
